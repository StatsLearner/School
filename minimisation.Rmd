---
title: "Minimisation"
output: html_document
---

## Introduction
I heard "minimisation", which is one of randomising methods used in clinical trials. For details, take a look at https://en.wikipedia.org/wiki/Minimisation_(clinical_trials)


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Library
```{r, message=FALSE}
library(tidyverse)
library(ggplot2)
```

## Dataset

I assume that there are 3 strata, A, B, and C. A andC have two levels while B has 3. These levels are sampled with an equal probability in each stratum.

Treatment column which includes only NA is combined to complete the dataset.

```{r}
set.seed(12345)
# sample size
# Later on counting may fail if a sample size is small and not all levels in starata exist in the dataset
n<-500

# Create each column of the dataset of enrolling patient
s.a <- sample(1:2, size = n, replace = TRUE, prob = c(0.5, 0.5)) # StratumA
s.b <- sample(1:3, size = n, replace = TRUE, prob = c(1/3, 1/3, 1/3)) #StratumB
s.c <- sample(1:2, size = n, replace = TRUE, prob = c(0.5, 0.5)) #StratumC

# Combine the columns
d <- data.frame(ptid = 1:n, 
                StratumA = s.a, 
                StratumB = s.b, 
                StratumC = s.c, 
                Treatment = matrix(NA,nrow = n, ncol = 1)) # Empty column for treatment allocation

```



Let's check if each stratum has a even distribution of levels.
Interestingly in this case, I get quite uneven proportions in Stratum A even with `n=500`. This is not the focus of this simulation, but this is influential to final simulation results. 

```{r}
# Check the patient background
d %>%
  select(ptid, StratumA, StratumB, StratumC) %>%
  pivot_longer(cols = -ptid, names_to = "Strata", values_to = "level") %>%
  ggplot(., aes(x = as.factor(level))
  ) + geom_bar(
  ) + facet_wrap(~Strata, scales = 'free_x'
  ) + ggtitle(paste("sample n=",n))
```


## Minimisation
### Preparation
I prepare two empty matrices to append values in loops to do minimisation. `res.rep` will have a dataset including treatment allocated, and `means.rep` will have mean proportions of each level in the strata over the total number of patients, i,e., `n=500` this time.

```{r}
k <- 50 #iteration (k>=2)

res.rep <- matrix(NA, nrow = k, ncol = 17)
colnames(res.rep) <- c("iteration", "Treat1", "Treat2",
                       "Treat1A1","Treat1A2","Treat2A1","Treat2A2",
                       "Treat1B1","Treat1B2","Treat1B3","Treat2B1",
                       "Treat2B2","Treat2B3",
                       "Treat1C1","Treat1C2","Treat2C1","Treat2C2")

means.rep <- matrix(NA, nrow = k, ncol = 17)
colnames(means.rep) <- c("iteration", "Treat1", "Treat2",
                         "Treat1A1","Treat1A2","Treat2A1","Treat2A2",
                         "Treat1B1","Treat1B2","Treat1B3","Treat2B1",
                         "Treat2B2","Treat2B3",
                         "Treat1C1","Treat1C2","Treat2C1","Treat2C2")

```


### Loop

I iterate a minimisation process `k=50` times. If the minimisation process finds that treatment 1 is more allocated than treatment 2 to enrolled patients who have similar strata as the next patient coming into, the original probabiliy is reduced by 20% and is increased by 20% otherwise. If the two treatments are allocated evenly in enrolled patients, the probability of treatment is as it is orginally set up.

In order to avoid that either of probabiliy assining either treatment goes over 1, the modification of probability goes back to 1 after allocation is done.

I want to know more fast and efficient approaches, but at least it is working!


```{r}
set.seed(12345678)

# Iterate a minimisation
for (j in 1:k) {
  
  # Remove Teatments allocated
  d[,5] <- matrix(NA, nrow = n, ncol = 1)
  d[1,5] <- sample(1:2,1, prob = c(0.5, 1-0.5)) # first allocation
  
  # Minimisation
  for (i in 1:(n-1)) {
    
    p<- 1 #Have a probability modifier back to 1
    
    tempA <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumA, Treatment) %>%
      filter(StratumA == d[i+1,2]) %>% #Count of treatment allocation by next StratumA
      tally() 
    
    tempB <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumB, Treatment) %>%
      filter(StratumB == d[i+1,3]) %>% #Count of treatment allocation by next StratumB
      tally() 
    
    tempC <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumC, Treatment) %>%
      filter(StratumC == d[i+1,4]) %>% #Count of treatment allocation by next StratumC
      tally() 
    
    # So as to rbind all, remove variable names after transforming to matrix
    if (nrow(tempA) == 0) {
      tempAm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempAm <- as.matrix(tempA)
      tempAm <- matrix(tempAm, ncol = ncol(tempA), dimnames = NULL)
    }
    
    if (nrow(tempB) == 0) {
      tempBm <- matrix(0, nrow = 1, ncol = 3)  # So not as to creat error in colnames, make an empty matrix
    } else {
      tempBm <- as.matrix(tempB)
      tempBm <- matrix(tempBm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    if (nrow(tempC) == 0) {
      tempCm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempCm <- as.matrix(tempC)
      tempCm <- matrix(tempCm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    # Rowbind and make a table to count up the number of treatment allocation in the strata of the next patient
    tempcross <- rbind(tempAm, tempBm, tempCm)[,2:3]
    colnames(tempcross) <- c("Treatment", "Count") 
    tempcross <- as.data.frame(tempcross)
    
    # Aggregate and count the number of allocations
    com.res0 <- tempcross %>%
      group_by(Treatment) %>%
      summarise(Count = sum(Count))

    if(com.res0$Treatment[1] == 0 & nrow(com.res0) > 1) {
      com.res <- com.res0[-1,]
    }
    
  
    # Change probability - minimisation
    if(com.res$Treatment[1] == 0 & nrow(com.res) == 1) { # No patient so far have the same strata 
      p <- 1 # Random allocation
    } else if (nrow(com.res) > 1 & com.res$Count[1] > com.res$Count[2]) {
      p <- p*0.8 # Decrease a probability allocating Treatment1
    } else if (nrow(com.res) > 1 & com.res$Count[1] < com.res$Count[2]) {
      p <- p*1.2 # Increase a probability allocating Treatment1
    } else if (nrow(com.res) > 1 & com.res$Count[1] == com.res$Count[2]) {
      p <- 1 # Random allocation
    } else if (com.res$Treatment == 1) {
      p <- p*0.8 # Decrease a probability allocating Treatment1
    } else {
      p <- p*1.2 # Increase a probability allocating Treatment1
    } 
    
    d[i+1,5] <- sample(1:2,1, prob = c(0.5*p, 1-0.5*p)) # allocation
    
  }


  # Store the result
  res.rep[j,1] <- j
  res.rep[j,2] <- table(factor(d$Treatment, levels = 1:2))[1]/n #Proportion of Treatment1 
  res.rep[j,3] <- table(factor(d$Treatment, levels = 1:2))[2]/n #Proportion of Treatment2
  
  # Avoid dividing by 0
  if (res.rep[j,2] == 0) {
    res.rep[j,6:7] <- 0
    res.rep[j,11:13] <- 0
    res.rep[j,16:17] <- 0
  } else {
    
    res.rep[j,6] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumA1
    res.rep[j,7] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumA2
    res.rep[j,11] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB1
    res.rep[j,12] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB2
    res.rep[j,13] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,3]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB3
    res.rep[j,16] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumC1
    res.rep[j,17] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumC2
    
  }
  
  # Avoid dividing by 0
  if (res.rep[j,1] == 0) {
    
    res.rep[j,4:5] <- 0
    res.rep[j,8:10] <- 0
    res.rep[j,14:15] <- 0
    
  } else {
    
    res.rep[j,4] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumA1
    res.rep[j,5] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumA2
    
    res.rep[j,8] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumB, levels = 1:3))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB1
    res.rep[j,9] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumB, levels = 1:3))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB2
    res.rep[j,10] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[1,3]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB3
    
    res.rep[j,14] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumC1
    res.rep[j,15] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumC2
    
  }
  
  # Calculate means
  means.rep[j,] <- cbind(j,t(colMeans(res.rep[,-1], na.rm = TRUE)))
  
}

```


### Plot results
The first plot shows you the proportionds of treatment 1 in some specified levels of strata. Since Stratum B has three levels, its theoretically ideal proportiion is approx. 0.33 and it looks being allocated well.

Stratum C also looks well allocated whereas Stratum A has the slightly higher proportion of treatment 1 and the proportion of treatment 1 in total varies a lot.

The second plot shows you the histograms of the number of samples iterated in which the proportion of patients who are in each stratum level in total tretment 1 allocation. The specified levels are different from those in the first plot, but it enables checking the precision of the minimisation process. Although the distributions are not close to a normal dist, since the dispersions are small in size, it might have done the minimisation fairely well.

The third plot shows you mean proportions in each iteration. As the number of iteration increases, the means should approach to the theoretical means. However, 50 time iterations might not be sufficient to see the expected convergence.


```{r}
#### Plot ####

# Transforming data
res.rep <- as.data.frame(res.rep)
means.rep <- as.data.frame(means.rep)

# Geom_point chronologically
ggplot(data = res.rep, aes(x=iteration)
       ) + geom_point(aes(y=Treat1, colour = "Total"), alpha = 0.4
                      ) + geom_point(aes(y=Treat1A1, colour = "A1"), alpha = 0.4
                                     ) + geom_point(aes(y=Treat1B1, colour = "B1"), alpha = 0.4
                                                    ) + geom_point(aes(y=Treat1C1, color="C1"), alpha = 0.4
                                                                   ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))


# Histograms
res.rep %>%
  select(iteration, Treat1C1, Treat1C2, Treat1B1, Treat1B2) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "percent") %>%
  ggplot(., aes(x=percent)
         ) + geom_histogram(binwidth = 0.005
         ) + facet_wrap(~type, scales = 'free_x'
                        ) + theme(axis.text.x = element_text(angle = 90, hjust = 1)
                                  ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))


# Convergence
means.rep %>%
  select(iteration, Treat1, Treat1B1, Treat1B2, Treat1B3) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "meanprop") %>%
  ggplot(., aes(x=iteration, y=meanprop)
         ) + geom_line(stat = "identity"
                       ) + facet_wrap(~type, scales = 'free_y'
                                      ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))

```

