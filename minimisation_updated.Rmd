---
title: "Minimisation"
output: html_document
---

## Introduction
I got to know "minimisation", which is one of randomising methods used in clinical trials. Here, I simulate minimisation process and see how treatment will be allocated. For details, take a look at https://en.wikipedia.org/wiki/Minimisation_(clinical_trials)

This is my secon shot of doing this with a different probability modification to reduce imbalance on treatment allocation.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Library
```{r, message=FALSE}
library(tidyverse)
library(ggplot2)
```

## Dataset

I assume that there are 3 strata, A, B, and C. A and C have two levels while B has 3. These levels are sampled with an equal probability in each stratum.

Treatment column which includes only NA is combined to complete the dataset.

```{r}
set.seed(12345)
# sample size
# Later on counting may fail if a sample size is small and not all levels in starata exist in the dataset
n<-500

# Create each column of the dataset of enrolling patient
s.a <- sample(1:2, size = n, replace = TRUE, prob = c(0.5, 0.5)) # StratumA
s.b <- sample(1:3, size = n, replace = TRUE, prob = c(1/3, 1/3, 1/3)) #StratumB
s.c <- sample(1:2, size = n, replace = TRUE, prob = c(0.5, 0.5)) #StratumC

# Combine the columns
d <- data.frame(ptid = 1:n, 
                StratumA = s.a, 
                StratumB = s.b, 
                StratumC = s.c, 
                Treatment = matrix(NA,nrow = n, ncol = 1)) # Empty column for treatment allocation

```



Let's check if each stratum has a even distribution of levels.
Interestingly in this case, I get quite uneven proportions in Stratum A even with `n=500`. This is not the focus of this simulation, but this is influential to final simulation results. 

```{r}
# Check the patient background
d %>%
  select(ptid, StratumA, StratumB, StratumC) %>%
  pivot_longer(cols = -ptid, names_to = "Strata", values_to = "level") %>%
  ggplot(., aes(x = as.factor(level))
  ) + geom_bar(
  ) + facet_wrap(~Strata, scales = 'free_x'
  ) + ggtitle(paste("sample n=",n))
```


## Minimisation
### Preparation
I prepare two empty matrices to append values in loops to do minimisation. `res.rep` will have a dataset including proportions of treatment 1 and treatment 2 allocated, and `means.rep` will have mean proportions in each level in the strata over the total number of patients, i,e., `n=500` this time.

```{r}
k <- 100 #iteration (k>=2)

res.rep <- matrix(NA, nrow = k, ncol = 17)
colnames(res.rep) <- c("iteration", "Treat1", "Treat2",
                       "Treat1A1","Treat1A2","Treat2A1","Treat2A2",
                       "Treat1B1","Treat1B2","Treat1B3","Treat2B1",
                       "Treat2B2","Treat2B3",
                       "Treat1C1","Treat1C2","Treat2C1","Treat2C2")

means.rep <- matrix(NA, nrow = k, ncol = 17)
colnames(means.rep) <- c("iteration", "Treat1", "Treat2",
                         "Treat1A1","Treat1A2","Treat2A1","Treat2A2",
                         "Treat1B1","Treat1B2","Treat1B3","Treat2B1",
                         "Treat2B2","Treat2B3",
                         "Treat1C1","Treat1C2","Treat2C1","Treat2C2")

```



### Loop 1-1: Coercing allocations the proportions that the number of patients in one level in each stratum against the number of either of treatments is allocated

I iterate a minimisation process `k=100` times. If the minimisation process finds that treatment 1 is more allocated than treatment 2 to enrolled patients who have similar strata as the next patient coming into, this process gives treatment 2, and vice versa.

I want to know more fast and efficient approaches, but at least it is working!

In this Loop1, I calculated **proportions divided by the total number of treatment allocations**. For example, the number of patients who are in StratumA1 and recieve treatment 1, divided by the number of total patients who recieve treatment 1; and this proportion is ideally 0.5, but the each level of StratumB should have 1/3 each.

In clinical trials, we aim to have similar proportions of each stratum in different intervention groups. Therefore, these proportions will be equal between different intervention groups.

```{r}
set.seed(12345678)

# Iterate a minimisation
for (j in 1:k) {
  
  # Remove Teatments allocated
  d[,5] <- matrix(NA, nrow = n, ncol = 1)
  d[1,5] <- sample(1:2,1, prob = c(0.5, 1-0.5)) # first allocation
  
  # Minimisation
  for (i in 1:(n-1)) {
    
    tempA <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumA, Treatment) %>%
      filter(StratumA == d[i+1,2]) %>% #Count of treatment allocation by next StratumA
      tally() 
    
    tempB <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumB, Treatment) %>%
      filter(StratumB == d[i+1,3]) %>% #Count of treatment allocation by next StratumB
      tally() 
    
    tempC <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumC, Treatment) %>%
      filter(StratumC == d[i+1,4]) %>% #Count of treatment allocation by next StratumC
      tally() 
    
    # So as to rbind all, remove variable names after transforming to matrix
    if (nrow(tempA) == 0) {
      tempAm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempAm <- as.matrix(tempA)
      tempAm <- matrix(tempAm, ncol = ncol(tempA), dimnames = NULL)
    }
    
    if (nrow(tempB) == 0) {
      tempBm <- matrix(0, nrow = 1, ncol = 3)  # So not as to creat error in colnames, make an empty matrix
    } else {
      tempBm <- as.matrix(tempB)
      tempBm <- matrix(tempBm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    if (nrow(tempC) == 0) {
      tempCm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempCm <- as.matrix(tempC)
      tempCm <- matrix(tempCm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    # Rowbind and make a table to count up the number of treatment allocation in the strata of the next patient
    tempcross <- rbind(tempAm, tempBm, tempCm)[,2:3]
    colnames(tempcross) <- c("Treatment", "Count") 
    tempcross <- as.data.frame(tempcross)
    
    # Aggregate and count the number of allocations
    com.res <- tempcross %>%
      group_by(Treatment) %>%
      summarise(Count = sum(Count))

    if(com.res$Treatment[1] == 0 & nrow(com.res) > 1) {
      com.res <- com.res[-1,]
    }
    
  
    # Change probability - minimisation
    if(com.res$Treatment[1] == 0 & nrow(com.res) == 1) { # No patient so far have the same strata 
      d[i+1,5] <- sample(1:2,1, prob = c(0.5, 0.5)) # Random allocation
    } else if (nrow(com.res) > 1 & com.res$Count[1] > com.res$Count[2]) {
      d[i+1,5] <- 2 #coercing
    } else if (nrow(com.res) > 1 & com.res$Count[1] < com.res$Count[2]) {
      d[i+1,5] <- 1 #coercing
    } else if (nrow(com.res) > 1 & com.res$Count[1] == com.res$Count[2]) {
      d[i+1,5] <- sample(1:2,1, prob = c(0.5, 0.5)) # Random allocation
    } else if (com.res$Treatment == 1) { # This is when only one treatment is allocated before.
     d[i+1,5] <- 2 #coercing
    } else {
      d[i+1,5] <- 1 #coercing
    } 
    
  }

 
  # Store the result
  res.rep[j,1] <- j
  res.rep[j,2] <- table(factor(d$Treatment, levels = 1:2))[1]/n #Proportion of Treatment1 
  res.rep[j,3] <- table(factor(d$Treatment, levels = 1:2))[2]/n #Proportion of Treatment2
  
  # Avoid dividing by 0
  if (res.rep[j,2] == 0) {
    res.rep[j,6:7] <- 0
    res.rep[j,11:13] <- 0
    res.rep[j,16:17] <- 0
  } else {
    
    res.rep[j,6] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumA, levels = 1:2))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumA1
    res.rep[j,7] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumA, levels = 1:2))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumA2
    res.rep[j,11] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB1
    res.rep[j,12] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB2
    res.rep[j,13] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[2,3]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB3
    res.rep[j,16] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumC, levels = 1:2))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumC1
    res.rep[j,17] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumC, levels = 1:2))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumC2
    
  }
  
  # Avoid dividing by 0
  if (res.rep[j,1] == 0) {
    
    res.rep[j,4:5] <- 0
    res.rep[j,8:10] <- 0
    res.rep[j,14:15] <- 0
    
  } else {
    
    res.rep[j,4] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumA, levels = 1:2))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumA1
    res.rep[j,5] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumA, levels = 1:2))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumA2
    
    res.rep[j,8] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB1
    res.rep[j,9] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB2
    res.rep[j,10] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[1,3]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB3
    
    res.rep[j,14] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumC, levels = 1:2))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumC1
    res.rep[j,15] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumC, levels = 1:2))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumC2
    
  }
  
  # Calculate means
  means.rep[j,] <- cbind(j,t(colMeans(res.rep[,-1], na.rm = TRUE)))
  
}

```


### Plot results 1-1
The first plot shows you the proportions of each stratum level in the total number of patients who are given treatment 1, except for the `total` category which expresses the proportion of treatment 1 in `n=500`. Since I coerce either of treatments over another, therefore there are very little variabilities in these proportions.


The second plot shows you distributions of of each proportion. Since there are very little variabilities, histograms do not have any sense.


The third plot shows you means of each set of proportions. This may be of little use too.Clearly, `Treat1A1` converges to a higher value than expected. Presumaly because the imbalance in A in the first place, A is a bit shifted to a higher set of proportions than their theoretical values, but other two proportions of different strata look good. The total proportion of treatment 1 has a larger variance.


```{r}
#### Plot ####

# Transforming data
res.rep <- as.data.frame(res.rep)
means.rep <- as.data.frame(means.rep)

# Geom_point chronologically
ggplot(data = res.rep, aes(x=iteration)
       ) + geom_point(aes(y=Treat1, colour = "Total"), alpha = 0.4
                      ) + geom_point(aes(y=Treat1A1, colour = "A1"), alpha = 0.4
                                     ) + geom_point(aes(y=Treat1B1, colour = "B1"), alpha = 0.4
                                                    ) + geom_point(aes(y=Treat1C1, color="C1"), alpha = 0.4
                                                                   ) + ggtitle(paste(k ," times iteration",",each sample n=",n)) 


# Histograms
res.rep %>%
  select(iteration, Treat1, Treat1A1, Treat1B1, Treat1C1) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "percent") %>%
  ggplot(., aes(x=percent)
         ) + geom_histogram(binwidth = 0.005
         ) + facet_wrap(~type,
                        ) + theme(axis.text.x = element_text(angle = 90, hjust = 1)
                                  ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))


# Convergence
means.rep %>%
  select(iteration, Treat1, Treat1A1, Treat1B1, Treat1C1) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "meanprop") %>%
  ggplot(., aes(x=iteration, y=meanprop)
         ) + geom_line(stat = "identity"
                       ) + facet_wrap(~type, 
                                      ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))

```


### Loop 1-2: Coercing allocations the proportions that the number of patients allocated either of treatments in each stratum level.

This loop has the same minimisation process but has **a different method to calculate proportions**. Here, I calculate proportions in each stratum level. For example, the number of patients who are in the Stratum A1 and recieve treatment 1, divided by the number of patients who are in the same stratum. These proportions are ideally 0.5 in all different stratum level.

So that I can compare the two methods, I use the same dataset but have different containers of results.

```{r}
res.rep2 <- matrix(NA, nrow = k, ncol = 17)
colnames(res.rep2) <- c("iteration", "Treat1", "Treat2",
                       "Treat1A1","Treat1A2","Treat2A1","Treat2A2",
                       "Treat1B1","Treat1B2","Treat1B3","Treat2B1",
                       "Treat2B2","Treat2B3",
                       "Treat1C1","Treat1C2","Treat2C1","Treat2C2")

means.rep2 <- matrix(NA, nrow = k, ncol = 17)
colnames(means.rep2) <- c("iteration", "Treat1", "Treat2",
                         "Treat1A1","Treat1A2","Treat2A1","Treat2A2",
                         "Treat1B1","Treat1B2","Treat1B3","Treat2B1",
                         "Treat2B2","Treat2B3",
                         "Treat1C1","Treat1C2","Treat2C1","Treat2C2")
```



```{r}
set.seed(12345678)

# Iterate a minimisation
for (j in 1:k) {
  
  # Remove Teatments allocated
  d[,5] <- matrix(NA, nrow = n, ncol = 1)
  d[1,5] <- sample(1:2,1, prob = c(0.5, 1-0.5)) # first allocation
  
  # Minimisation
  for (i in 1:(n-1)) {
    
    p<- 1 #Have a probability modifier back to 1
    
    tempA <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumA, Treatment) %>%
      filter(StratumA == d[i+1,2]) %>% #Count of treatment allocation by next StratumA
      tally() 
    
    tempB <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumB, Treatment) %>%
      filter(StratumB == d[i+1,3]) %>% #Count of treatment allocation by next StratumB
      tally() 
    
    tempC <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumC, Treatment) %>%
      filter(StratumC == d[i+1,4]) %>% #Count of treatment allocation by next StratumC
      tally() 
    
    # So as to rbind all, remove variable names after transforming to matrix
    if (nrow(tempA) == 0) {
      tempAm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempAm <- as.matrix(tempA)
      tempAm <- matrix(tempAm, ncol = ncol(tempA), dimnames = NULL)
    }
    
    if (nrow(tempB) == 0) {
      tempBm <- matrix(0, nrow = 1, ncol = 3)  # So not as to creat error in colnames, make an empty matrix
    } else {
      tempBm <- as.matrix(tempB)
      tempBm <- matrix(tempBm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    if (nrow(tempC) == 0) {
      tempCm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempCm <- as.matrix(tempC)
      tempCm <- matrix(tempCm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    # Rowbind and make a table to count up the number of treatment allocation in the strata of the next patient
    tempcross <- rbind(tempAm, tempBm, tempCm)[,2:3]
    colnames(tempcross) <- c("Treatment", "Count") 
    tempcross <- as.data.frame(tempcross)
    
    # Aggregate and count the number of allocations
    com.res <- tempcross %>%
      group_by(Treatment) %>%
      summarise(Count = sum(Count))

    if(com.res$Treatment[1] == 0 & nrow(com.res) > 1) {
      (com.res <- com.res[-1,])
    }
    
  
    # Change probability - minimisation
    if(com.res$Treatment[1] == 0 & nrow(com.res) == 1) { # No patient so far have the same strata 
      d[i+1,5] <- sample(1:2,1, prob = c(0.5, 0.5)) # Random allocation
    } else if (nrow(com.res) > 1 & com.res$Count[1] > com.res$Count[2]) {
      d[i+1,5] <- 2 # Decrease a probability allocating Treatment1
    } else if (nrow(com.res) > 1 & com.res$Count[1] < com.res$Count[2]) {
      d[i+1,5] <- 1 # Increase a probability allocating Treatment1
    } else if (nrow(com.res) > 1 & com.res$Count[1] == com.res$Count[2]) {
      d[i+1,5] <- sample(1:2,1, prob = c(0.5, 0.5)) # Random allocation
    } else if (com.res$Treatment == 1) { # This is when only one treatment is allocated before.
      d[i+1,5] <- 2 # Decrease a probability allocating Treatment1
    } else {
      d[i+1,5] <- 1 # Increase a probability allocating Treatment1
    } 
    
  }

 
  # Store the result
  res.rep2[j,1] <- j
  res.rep2[j,2] <- table(factor(d$Treatment, levels = 1:2))[1]/n #Proportion of Treatment1 
  res.rep2[j,3] <- table(factor(d$Treatment, levels = 1:2))[2]/n #Proportion of Treatment2
  
  # Avoid dividing by 0
  if (res.rep2[j,2] == 0) {
    res.rep2[j,6:7] <- 0
    res.rep2[j,11:13] <- 0
    res.rep2[j,16:17] <- 0
  } else {
    
    res.rep2[j,6] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[2,1]/table(factor(d$StratumA, levels = 1:2))[1] #Proportion of Treatment2 and StratumA1
    res.rep2[j,7] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[2,2]/table(factor(d$StratumA, levels = 1:2))[2] #Proportion of Treatment2 and StratumA2
    res.rep2[j,11] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,1]/table(factor(d$StratumB, levels = 1:3))[1] #Proportion of Treatment2 and StratumB1
    res.rep2[j,12] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,2]/table(factor(d$StratumB, levels = 1:3))[2] #Proportion of Treatment2 and StratumB2
    res.rep2[j,13] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,3]/table(factor(d$StratumB, levels = 1:3))[3] #Proportion of Treatment2 and StratumB3
    res.rep2[j,16] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[2,1]/table(factor(d$StratumC, levels = 1:2))[1] #Proportion of Treatment2 and StratumC1
    res.rep2[j,17] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[2,2]/table(factor(d$StratumC, levels = 1:2))[2] #Proportion of Treatment2 and StratumC2
    
  }
  
  # Avoid dividing by 0
  if (res.rep2[j,1] == 0) {
    
    res.rep2[j,4:5] <- 0
    res.rep2[j,8:10] <- 0
    res.rep2[j,14:15] <- 0
    
  } else {
    
    res.rep2[j,4] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[1,1]/table(factor(d$StratumA, levels = 1:2))[1] #Proportion of Treatment1 and StratumA1
    res.rep2[j,5] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[1,2]/table(factor(d$StratumA, levels = 1:2))[2] #Proportion of Treatment1 and StratumA2
    
    res.rep2[j,8] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumB, levels = 1:3))[1,1]/table(factor(d$StratumB, levels = 1:3))[1] #Proportion of Treatment1 and StratumB1
    res.rep2[j,9] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumB, levels = 1:3))[1,2]/table(factor(d$StratumB, levels = 1:3))[2] #Proportion of Treatment1 and StratumB2
    res.rep2[j,10] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[1,3]/table(factor(d$StratumB, levels = 1:3))[3] #Proportion of Treatment1 and StratumB3
    
    res.rep2[j,14] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[1,1]/table(factor(d$StratumC, levels = 1:2))[1] #Proportion of Treatment1 and StratumC1
    res.rep2[j,15] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[1,2]/table(factor(d$StratumC, levels = 1:2))[2] #Proportion of Treatment1 and StratumC2
    
  }
  
  # Calculate means
  means.rep2[j,] <- cbind(j,t(colMeans(res.rep2[,-1], na.rm = TRUE)))
  
}

```


### Plot results 1-2

Everthing is aroud 0.5 as expceted.

```{r}
#### Plot ####

# Transforming data
res.rep2 <- as.data.frame(res.rep2)
means.rep2 <- as.data.frame(means.rep2)

# Geom_point chronologically
ggplot(data = res.rep2, aes(x=iteration)
       ) + geom_point(aes(y=Treat1, colour = "Total"), alpha = 0.4
                      ) + geom_point(aes(y=Treat1A1, colour = "A1"), alpha = 0.4
                                     ) + geom_point(aes(y=Treat1B1, colour = "B1"), alpha = 0.4
                                                    ) + geom_point(aes(y=Treat1C1, color="C1"), alpha = 0.4
                                                                   ) + ggtitle(paste(k ," times iteration",",each sample n=",n)) + ylim(0.45, 0.55) 


# Histograms
res.rep2 %>%
  select(iteration, Treat1A1, Treat1B1, Treat1B2, Treat1C1) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "percent") %>%
  ggplot(., aes(x=percent)
         ) + geom_histogram(binwidth = 0.005
         ) + facet_wrap(~type, 
                        ) + theme(axis.text.x = element_text(angle = 90, hjust = 1)
                                  ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))


# Convergence
means.rep2 %>%
  select(iteration, Treat1, Treat1A1, Treat1B1, Treat1C1) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "meanprop") %>%
  ggplot(., aes(x=iteration, y=meanprop)
         ) + geom_line(stat = "identity"
                       ) + facet_wrap(~type, 
                                      ) + ggtitle(paste(k ," times iteration", ",each sample n=",n)) + ylim(0.45, 0.55)

```



### Loop 2-1: Modify probality to reduce imbalance using the proportions adopted in Loop1-1.

This time, if the minimisation process finds that treatment 1 is more allocated than treatment 2 to enrolled patients who have similar strata as the next patient coming into, the original probabiliy is reduced by `10%` and is increased by `10%` otherwise. If the two treatments are allocated evenly in enrolled patients, the probability of treatment is as it is orginally set up.

Here, I calculated **proportions divided by the total number of treatment allocations**. For example, the number of patients who are in StratumA1 and recieve treatment 1, divided by the number of total patients who recieve treatment 1; and this proportion is ideally 0.5, but the each level of StratumB should have 1/3 each.

```{r}
set.seed(12345678)

# Iterate a minimisation
for (j in 1:k) {
  
  # Remove Teatments allocated
  d[,5] <- matrix(NA, nrow = n, ncol = 1)
  d[1,5] <- sample(1:2,1, prob = c(0.5, 1-0.5)) # first allocation
  
  # Minimisation
  for (i in 1:(n-1)) {
    
    p<- 1 #Have a probability modifier back to 1
    
    tempA <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumA, Treatment) %>%
      filter(StratumA == d[i+1,2]) %>% #Count of treatment allocation by next StratumA
      tally() 
    
    tempB <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumB, Treatment) %>%
      filter(StratumB == d[i+1,3]) %>% #Count of treatment allocation by next StratumB
      tally() 
    
    tempC <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumC, Treatment) %>%
      filter(StratumC == d[i+1,4]) %>% #Count of treatment allocation by next StratumC
      tally() 
    
    # So as to rbind all, remove variable names after transforming to matrix
    if (nrow(tempA) == 0) {
      tempAm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempAm <- as.matrix(tempA)
      tempAm <- matrix(tempAm, ncol = ncol(tempA), dimnames = NULL)
    }
    
    if (nrow(tempB) == 0) {
      tempBm <- matrix(0, nrow = 1, ncol = 3)  # So not as to creat error in colnames, make an empty matrix
    } else {
      tempBm <- as.matrix(tempB)
      tempBm <- matrix(tempBm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    if (nrow(tempC) == 0) {
      tempCm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempCm <- as.matrix(tempC)
      tempCm <- matrix(tempCm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    # Rowbind and make a table to count up the number of treatment allocation in the strata of the next patient
    tempcross <- rbind(tempAm, tempBm, tempCm)[,2:3]
    colnames(tempcross) <- c("Treatment", "Count") 
    tempcross <- as.data.frame(tempcross)
    
    # Aggregate and count the number of allocations
    com.res0 <- tempcross %>%
      group_by(Treatment) %>%
      summarise(Count = sum(Count))

    if(com.res0$Treatment[1] == 0 & nrow(com.res0) > 1) {
      com.res <- com.res0[-1,]
    }
    
  
    # Change probability - minimisation
    if(com.res$Treatment[1] == 0 & nrow(com.res) == 1) { # No patient so far have the same strata 
      p <- 1 # Random allocation
    } else if (nrow(com.res) > 1 & com.res$Count[1] > com.res$Count[2]) {
      p <- p*0.9 # Decrease a probability allocating Treatment1
    } else if (nrow(com.res) > 1 & com.res$Count[1] < com.res$Count[2]) {
      p <- p*1.1 # Increase a probability allocating Treatment1
    } else if (nrow(com.res) > 1 & com.res$Count[1] == com.res$Count[2]) {
      p <- 1 # Random allocation
    } else if (com.res$Treatment == 1) { # This is when only one treatment is allocated before.
      p <- p*0.9 # Decrease a probability allocating Treatment1
    } else {
      p <- p*1.1 # Increase a probability allocating Treatment1
    } 
    
    d[i+1,5] <- sample(1:2,1, prob = c(0.5*p, 1-0.5*p)) # allocation
    
  }

 
  # Store the result
  res.rep[j,1] <- j
  res.rep[j,2] <- table(factor(d$Treatment, levels = 1:2))[1]/n #Proportion of Treatment1 
  res.rep[j,3] <- table(factor(d$Treatment, levels = 1:2))[2]/n #Proportion of Treatment2
  
  # Avoid dividing by 0
  if (res.rep[j,2] == 0) {
    res.rep[j,6:7] <- 0
    res.rep[j,11:13] <- 0
    res.rep[j,16:17] <- 0
  } else {
    
    res.rep[j,6] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumA, levels = 1:2))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumA1
    res.rep[j,7] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumA, levels = 1:2))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumA2
    res.rep[j,11] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB1
    res.rep[j,12] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB2
    res.rep[j,13] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[2,3]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumB3
    res.rep[j,16] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumC, levels = 1:2))[2,1]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumC1
    res.rep[j,17] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumC, levels = 1:2))[2,2]/table(factor(d$Treatment, levels = 1:2))[2] #Proportion of Treatment2 and StratumC2
    
  }
  
  # Avoid dividing by 0
  if (res.rep[j,1] == 0) {
    
    res.rep[j,4:5] <- 0
    res.rep[j,8:10] <- 0
    res.rep[j,14:15] <- 0
    
  } else {
    
    res.rep[j,4] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumA, levels = 1:2))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumA1
    res.rep[j,5] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumA, levels = 1:2))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumA2
    
    res.rep[j,8] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB1
    res.rep[j,9] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB2
    res.rep[j,10] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumB, levels = 1:3))[1,3]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumB3
    
    res.rep[j,14] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumC, levels = 1:2))[1,1]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumC1
    res.rep[j,15] <- table(factor(d$Treatment, levels = 1:2), factor(d$StratumC, levels = 1:2))[1,2]/table(factor(d$Treatment, levels = 1:2))[1] #Proportion of Treatment1 and StratumC2
    
  }
  
  # Calculate means
  means.rep[j,] <- cbind(j,t(colMeans(res.rep[,-1], na.rm = TRUE)))
  
}

```


### Plot results 2-1
The first plot shows you the proportions of each stratum level in the total number of patients who are given treatment 1, except for the `total` category which expresses the proportion of treatment 1 in `n=500`. The plot has some variabilities in each variable.


The second plot shows you distributions of of each proportion. Fairly precise distributions are shown except for that of the overall proportion of treatment1.


The third plot shows you means of each set of proportions. They look quite stabilised.


```{r}
#### Plot ####

# Transforming data
res.rep <- as.data.frame(res.rep)
means.rep <- as.data.frame(means.rep)

# Geom_point chronologically
ggplot(data = res.rep, aes(x=iteration)
       ) + geom_point(aes(y=Treat1, colour = "Total"), alpha = 0.4
                      ) + geom_point(aes(y=Treat1A1, colour = "A1"), alpha = 0.4
                                     ) + geom_point(aes(y=Treat1B1, colour = "B1"), alpha = 0.4
                                                    ) + geom_point(aes(y=Treat1C1, color="C1"), alpha = 0.4
                                                                   ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))


# Histograms
res.rep %>%
  select(iteration, Treat1, Treat1A1, Treat1B1, Treat1C1) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "percent") %>%
  ggplot(., aes(x=percent)
         ) + geom_histogram(binwidth = 0.01
         ) + facet_wrap(~type,
                        ) + theme(axis.text.x = element_text(angle = 90, hjust = 1)
                                  ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))


# Convergence
means.rep %>%
  select(iteration, Treat1, Treat1A1, Treat1B1, Treat1C1) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "meanprop") %>%
  ggplot(., aes(x=iteration, y=meanprop)
         ) + geom_line(stat = "identity"
                       ) + facet_wrap(~type, 
                                      ) + ggtitle(paste(k ," times iteration", ",each sample n=",n)) 

```


### Loop 2-2: Modify probality to reduce imbalance using the proportions adopted in Loop1-2.

This loop has the same minimisation process but has **a different method to calculate proportions**. Here, I calculate proportions in each stratum level. For example, the number of patients who are in the Stratum A1 and recieve treatment 1, divided by the number of patients who are in the same stratum. These proportions are ideally 0.5 in all different stratum level.

So that I can compare the two methods, I use the same dataset but have different containers of results.

```{r}
res.rep2 <- matrix(NA, nrow = k, ncol = 17)
colnames(res.rep2) <- c("iteration", "Treat1", "Treat2",
                       "Treat1A1","Treat1A2","Treat2A1","Treat2A2",
                       "Treat1B1","Treat1B2","Treat1B3","Treat2B1",
                       "Treat2B2","Treat2B3",
                       "Treat1C1","Treat1C2","Treat2C1","Treat2C2")

means.rep2 <- matrix(NA, nrow = k, ncol = 17)
colnames(means.rep2) <- c("iteration", "Treat1", "Treat2",
                         "Treat1A1","Treat1A2","Treat2A1","Treat2A2",
                         "Treat1B1","Treat1B2","Treat1B3","Treat2B1",
                         "Treat2B2","Treat2B3",
                         "Treat1C1","Treat1C2","Treat2C1","Treat2C2")
```



```{r}
set.seed(12345678)

# Iterate a minimisation
for (j in 1:k) {
  
  # Remove Teatments allocated
  d[,5] <- matrix(NA, nrow = n, ncol = 1)
  d[1,5] <- sample(1:2,1, prob = c(0.5, 1-0.5)) # first allocation
  
  # Minimisation
  for (i in 1:(n-1)) {
    
    p<- 1 #Have a probability modifier back to 1
    
    tempA <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumA, Treatment) %>%
      filter(StratumA == d[i+1,2]) %>% #Count of treatment allocation by next StratumA
      tally() 
    
    tempB <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumB, Treatment) %>%
      filter(StratumB == d[i+1,3]) %>% #Count of treatment allocation by next StratumB
      tally() 
    
    tempC <- d[-(i+1):-n,] %>% #Pickup allocation until the previous allocation
      group_by(StratumC, Treatment) %>%
      filter(StratumC == d[i+1,4]) %>% #Count of treatment allocation by next StratumC
      tally() 
    
    # So as to rbind all, remove variable names after transforming to matrix
    if (nrow(tempA) == 0) {
      tempAm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempAm <- as.matrix(tempA)
      tempAm <- matrix(tempAm, ncol = ncol(tempA), dimnames = NULL)
    }
    
    if (nrow(tempB) == 0) {
      tempBm <- matrix(0, nrow = 1, ncol = 3)  # So not as to creat error in colnames, make an empty matrix
    } else {
      tempBm <- as.matrix(tempB)
      tempBm <- matrix(tempBm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    if (nrow(tempC) == 0) {
      tempCm <- matrix(0, nrow = 1, ncol = 3) # So not as to creat error in colnames, make an empty matrix
    } else {
      tempCm <- as.matrix(tempC)
      tempCm <- matrix(tempCm, ncol = ncol(tempB), dimnames = NULL)
    }
    
    # Rowbind and make a table to count up the number of treatment allocation in the strata of the next patient
    tempcross <- rbind(tempAm, tempBm, tempCm)[,2:3]
    colnames(tempcross) <- c("Treatment", "Count") 
    tempcross <- as.data.frame(tempcross)
    
    # Aggregate and count the number of allocations
    com.res0 <- tempcross %>%
      group_by(Treatment) %>%
      summarise(Count = sum(Count))

    if(com.res0$Treatment[1] == 0 & nrow(com.res0) > 1) {
      com.res <- com.res0[-1,]
    }
    
  
    # Change probability - minimisation
    if(com.res$Treatment[1] == 0 & nrow(com.res) == 1) { # No patient so far have the same strata 
      p <- 1 # Random allocation
    } else if (nrow(com.res) > 1 & com.res$Count[1] > com.res$Count[2]) {
      p <- p*0.9 # Decrease a probability allocating Treatment1
    } else if (nrow(com.res) > 1 & com.res$Count[1] < com.res$Count[2]) {
      p <- p*1.1 # Increase a probability allocating Treatment1
    } else if (nrow(com.res) > 1 & com.res$Count[1] == com.res$Count[2]) {
      p <- 1 # Random allocation
    } else if (com.res$Treatment == 1) { # This is when only one treatment is allocated before.
      p <- p*0.9 # Decrease a probability allocating Treatment1
    } else {
      p <- p*1.1 # Increase a probability allocating Treatment1
    } 
    
    d[i+1,5] <- sample(1:2,1, prob = c(0.5*p, 1-0.5*p)) # allocation
    
  }

 
  # Store the result
  res.rep2[j,1] <- j
  res.rep2[j,2] <- table(factor(d$Treatment, levels = 1:2))[1]/n #Proportion of Treatment1 
  res.rep2[j,3] <- table(factor(d$Treatment, levels = 1:2))[2]/n #Proportion of Treatment2
  
  # Avoid dividing by 0
  if (res.rep2[j,2] == 0) {
    res.rep2[j,6:7] <- 0
    res.rep2[j,11:13] <- 0
    res.rep2[j,16:17] <- 0
  } else {
    
    res.rep2[j,6] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[2,1]/table(factor(d$StratumA, levels = 1:2))[1] #Proportion of Treatment2 and StratumA1
    res.rep2[j,7] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[2,2]/table(factor(d$StratumA, levels = 1:2))[2] #Proportion of Treatment2 and StratumA2
    res.rep2[j,11] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,1]/table(factor(d$StratumB, levels = 1:3))[1] #Proportion of Treatment2 and StratumB1
    res.rep2[j,12] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,2]/table(factor(d$StratumB, levels = 1:3))[2] #Proportion of Treatment2 and StratumB2
    res.rep2[j,13] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[2,3]/table(factor(d$StratumB, levels = 1:3))[3] #Proportion of Treatment2 and StratumB3
    res.rep2[j,16] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[2,1]/table(factor(d$StratumC, levels = 1:2))[1] #Proportion of Treatment2 and StratumC1
    res.rep2[j,17] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[2,2]/table(factor(d$StratumC, levels = 1:2))[2] #Proportion of Treatment2 and StratumC2
    
  }
  
  # Avoid dividing by 0
  if (res.rep2[j,1] == 0) {
    
    res.rep2[j,4:5] <- 0
    res.rep2[j,8:10] <- 0
    res.rep2[j,14:15] <- 0
    
  } else {
    
    res.rep2[j,4] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[1,1]/table(factor(d$StratumA, levels = 1:2))[1] #Proportion of Treatment1 and StratumA1
    res.rep2[j,5] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumA, levels = 1:2))[1,2]/table(factor(d$StratumA, levels = 1:2))[2] #Proportion of Treatment1 and StratumA2
    
    res.rep2[j,8] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumB, levels = 1:3))[1,1]/table(factor(d$StratumB, levels = 1:3))[1] #Proportion of Treatment1 and StratumB1
    res.rep2[j,9] <- table(factor(d$Treatment, levels = 1:2), 
                          factor(d$StratumB, levels = 1:3))[1,2]/table(factor(d$StratumB, levels = 1:3))[2] #Proportion of Treatment1 and StratumB2
    res.rep2[j,10] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumB, levels = 1:3))[1,3]/table(factor(d$StratumB, levels = 1:3))[3] #Proportion of Treatment1 and StratumB3
    
    res.rep2[j,14] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[1,1]/table(factor(d$StratumC, levels = 1:2))[1] #Proportion of Treatment1 and StratumC1
    res.rep2[j,15] <- table(factor(d$Treatment, levels = 1:2), 
                           factor(d$StratumC, levels = 1:2))[1,2]/table(factor(d$StratumC, levels = 1:2))[2] #Proportion of Treatment1 and StratumC2
    
  }
  
  # Calculate means
  means.rep2[j,] <- cbind(j,t(colMeans(res.rep2[,-1], na.rm = TRUE)))
  
}

```


### Plot results 2-2

In the first plot, all of them is scattered around 0.5, which is a good sign. The histograms are dispersed compared to those in the ones above and the forms are not clearly normal. The convergences are also not well achieved, as relative to the ones above, but they will be better converged if the number of iterations increases.

```{r}
#### Plot ####

# Transforming data
res.rep2 <- as.data.frame(res.rep2)
means.rep2 <- as.data.frame(means.rep2)

# Geom_point chronologically
ggplot(data = res.rep2, aes(x=iteration)
       ) + geom_point(aes(y=Treat1, colour = "Total"), alpha = 0.4
                      ) + geom_point(aes(y=Treat1A1, colour = "A1"), alpha = 0.4
                                     ) + geom_point(aes(y=Treat1B1, colour = "B1"), alpha = 0.4
                                                    ) + geom_point(aes(y=Treat1C1, color="C1"), alpha = 0.4
                                                                   ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))


# Histograms
res.rep2 %>%
  select(iteration, Treat1A1, Treat1B1, Treat1B2, Treat1C1) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "percent") %>%
  ggplot(., aes(x=percent)
         ) + geom_histogram(binwidth = 0.01
         ) + facet_wrap(~type, 
                        ) + theme(axis.text.x = element_text(angle = 90, hjust = 1)
                                  ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))


# Convergence
means.rep2 %>%
  select(iteration, Treat1, Treat1A1, Treat1B1, Treat1C1) %>%
  pivot_longer(cols = -iteration, names_to = "type", values_to = "meanprop") %>%
  ggplot(., aes(x=iteration, y=meanprop)
         ) + geom_line(stat = "identity"
                       ) + facet_wrap(~type, 
                                      ) + ggtitle(paste(k ," times iteration", ",each sample n=",n))

```


## Conclusion

Minimisation is a good method to reduce imbalance. I have not checked if each combination of strata levels has an equal treatment allocation though. I am not sure how, in reality, treatment allocation is adjusted, but it seems that just coercing one treatment over another when appropriate would be the best.
